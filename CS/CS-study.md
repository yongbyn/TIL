> [혼자공부하는컴퓨터구조+운영체제](https://search.shopping.naver.com/book/catalog/33824626625?cat_id=50010921&frm=PBOKMOD&query=%ED%98%BC%EC%9E%90+%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94+%EC%BB%B4%ED%93%A8%ED%84%B0+%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C&NaPm=ct%3Dlt312sds%7Cci%3D844548e8dd8a960c346be35ce939307f79e42506%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3Da6eadf79d7232b75fffb0cf6c8269c4ec7bf21d6) 를 보고 정리한 내용입니다.

혼자공부하는컴퓨터구조+운영체제
==============================

## 컴퓨터 구조
* 컴퓨터가 이해하는 정보 + 컴퓨터의 네 가지 핵심 부품
  - 컴퓨터가 이해하는 정보 : 데이터와 명령어
    + 데이터(data) : 컴퓨터가 이해하는 숫자, 문자, 이미지 동영상과 같은 정적인 정보
    + 명령어(instruction) : 컴퓨터를 작동시키는 정보
  - 컴퓨터의 네 가지 핵심 부품
    + 중앙처리장치(CPU) : 메모리에 저장된 명령어를 읽어 들이고, 읽어 들인 명령어를 해석하고, 실행하는 부품
      + 산술논리연산장치(ALU) : 계산을 위한 장치
      + 레지스터 : 임시 저장 장치, 프로그램 실행에 필요한 값을 임시로 저장(CPU 내 여러개 존재)
      + 제어장치 : 제어 신호를 내보내고 명령어를 해석하는 장치
    + 주기억장치(메모리) : 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품
      + 용량이 보조기억장치보다 작고, 전원이 종료되면 저장된 내용을 잃음(RAM)
    + 보조기억장치 : 메모리보다 크고, 전원이 종료되어도 저장된 내용을 잃지 않는 메모리를 보조하는 저장 장치(HDD,SSD, USB, DVD, CD-ROM)
    + 입출력장치 : 컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치(마이크, 스피커, 프린터, 마우스, 키보드)
* 시스템 버스 : 컴퓨터의 네 가지 핵심 부품들이 서로 정보를 주고받는 통로
  - 주소 버스 : 주소를 주고받는 통로
  - 데이터 버스 : 명령어와 데이터를 주고받는 통로
  - 제어 버스 : 제어 신호를 주고받는 통로

### 데이터
* 정보단위
  - 비트(bit) : 0과 1로 나타내는 컴퓨터가 표현하는 가장 작은 정보 단위( 1비트 : 0 / 1, 2비트 : 00 / 01 / 10 / 11 )
    + 1바이트(1byte) : 8비트
    + 1킬로바이트(1kB) : 1,000바이트
    + 1메가바이트(1MB) = 1,000킬로바이트
    + 1기가바이트(1GB) = 1,000메가바이트
    + 1테라바이트(1TB) = 1,000기가바이트
  - 비트는 이진수로 표현가능
  - 이진수의 음수는 2의 보수 (ex 11의 음수는 01이다. -(-x) = x 기 때문)
    + 2의 보수 : 어떤 수를 그보다 큰 2^n에서 뺀 값
  - 십육진법은 15를 넘어가는 시점에서 자리 올림하여 수를 표현함 (0~9,A~F)
* 0과 1로 문자를 표현하는 방법
  - 문자 집합(character set) : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
  - 문자 인코딩(character encoding) : 문자를 0과 1로 변환하는 과정(변환해야 컴퓨터가 이해함)
  - 문자 디코딩(character decoding) : 인코딩의 반대 과정, 즉 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정
* 아스키 코드(ASCII:American Standard Code for InforMation Interchange)
  - 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함한 초창기 문자 집합 중 하나
  - 7비트로 표현가능 → 2^7 = 128개(0~127)
    - 0 : null
* EUC-KR : 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식
* 유니코드 : 여러 나라의 문자들을 광범위하게 표현할 수 있는 통일된 문자 집합
  - ex) UTF-8(가장 대중적), UTF-16, UTF-32 → 유니코드 문자의 인코딩 방식

### 명령어
* 프로그래밍 언어
  - 고급 언어(high-level programming language) : 사람을 위한 언어(컴퓨터는 이해하지 못함)
  - 저급 언어(low-level programming language) : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    + 기계어(machine code) : 0과 1의 명령어 비트로 이루어진 언어(가독성을 위해 십육진수로 표현하기도 함)
    + 어셈블리어(assembly language) : 기계어를 읽기 편한 형태로 번역한 언어 (ex. push rbp / mov rbp, rsp  ...)
       + 어셈블리어를 이용해 복잡한 프로그램을 만들기 어려움 → 고급 언어 필요
       + 어셈블리어는 하드웨어와 밀접한 임베디드 개발자, 게임 개발자, 정보 보안 분야 등에서 많이 사용됨
* 고급언어 → 저급언어 변환
  - 컴파일 언어 : 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어(ex. C언어)
    + 컴파일 : 컴파일 언어로 작성된 소스 코드 전체가 저급 언어로 변환되는 과정
      + 코드 전체가 변환되기 때문에 오류가 하나라도 있으면 컴파일이 불가능함(실패함)
    + 컴파일러 : 컴파일을 수행해 주는 도구
  - 인터프리터 언어 : 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어(ex. Python)
    + 인터프리터 : 소스 코드가 한 줄씩 저급 언어로 변환하여 실행해 주는 도구(컴파일은 소스 코드 전체)
      + 소스 코드가 한 줄씩 실행되기 때문에 N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 수행됨
  - 실행 속도 : 컴파일 언어 > 인터프리터 언어 (in general)
 
### 명령어의 구조
* 명령어 = 연산 코드 + 오퍼랜드
  - 연산 코드 : 명령어가 수행할 연산(연산자) → 연산코드가 담기는 영역 : 연산 코드 필드
  - 오퍼랜드 : 연산에 사용할 데이터 혹은 데이터가 저장된 위치(피연산자) → 오퍼랜드가 담기는 영역 : 오퍼랜드 필드
* 주소 지정 방식 : 연산에 사용할 데이터 위치를 찾는 방법
  - 유효 주소 : 연산에 사용할 데이터가 저장된 위치
  - 즉시 주소 지정 방식 : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식, 가장 간단한 형태
    + 장점 : 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 이하 설명할 주소 지정 방식들보다 빠름
    + 단점 : 유효 주소를 표현할 수 있는 데이터의 크기가 작아짐
  - 직접 주소 지정 방식 : 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
    + 장점 : 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기가 즉시 방식보다 더 큼
    + 단점 : 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있음
  - 간접 주소 지정 방식 : 유효 주소의 주소를 오퍼랜드 필드에 명시
    + 장점 : 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓음
    + 단점 : 두 번의 메모리 접근이 필요하기 때문에 즉시, 직접 방식보다 일반적으로 느림
  - 레지스터 주소 지정 방식 : 직접 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
    + 장점 : 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름 → 직접 방식보다 더 빠르게 데이터에 접근할 수 있음
    + 단점 : 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음(직접 방식과 비슷)
  - 레지스터 간접 주소 지정 방식 : 연산에 사용할 데이터를 메모리에 저장하고 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
    + 장점 : 간접 주소 지정 방식과 비슷하지만, 메모리 접근하는 횟수가 한 번으로 줄어듬
    + 단점 : ?
* 정리(각각의 방식이 오퍼랜드 필드에 명시하는 값)
  - 즉시 주소 지정 방식 : 연산에 사용할 데이터
  - 직접 주소 지정 방식 : 유효 주소(메모리 주소)
  - 간접 주소 지정 방식 : 유효 주소의 주소
  - 레지스터 주소 지정 방식 : 유효 주소(레지스터 이름)
  - 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터

## CPU의 작동원리
* ALU(Arithmetic and Logical Unit)는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들임
  - 연산 결과와 플래그를 내보냄
* 제어장치는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들임
  - CPU 내부와 외부로 제어 신호를 내보냄
* 플래그 : 연산 결과에 대한 추가적인 상태 정보
* 반드시 알아야할 레지스터
  - 프로그램 카운터 : 메모리에서 가져올 명령어의 주소, 메모리에서 읽어 들일 명령어의 주소를 저장(명령어 포인터라고도 부름)
  - 명령어 레지스터 : 해석할 명령어, 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
    + 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냄
  - 메모리 주소 레지스터 : 메모리의 주소를 저장하는 레지스터
    + CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침
  - 메모리 버퍼 레지스터 : 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터(메모리 데이터 레지스터라고도 부름)
    + CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침
  - 플래그 레지스터 : 연산 결과 또는 CPU 상태에 대한 부가적인 정보(플래그)를 저장하는 레지스터
  - 범용 레지스터 : 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
  - 스택 포인터 : 스택의 최상단(메지막으로 저장한 값의 위치)을 저장하는 레지스터
    + 스택 주소 지정방식 : 스택과 스택 포인터를 이용한 주소 지정 방식
  - 베이스 레지스터 : 베이스 레지스터 주소 지정 방식에서 기준 주소가 되는 레지스터
    + 베이스 레지스터는 기준주소, 오퍼랜드는 기준 주소로부터 떨어진 거리로서의 역할을 함
    + 변위 주소 지정 방식 : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
      + 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉨
      + 상대 주소 지정 방식은 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
      + 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식
* 명령어 사이클 : 하나의 명령어가 처리되는 주기
  - 인출, 실행, 간접, 인터럽트 사이클로 구성됨
* 인터럽트 : cpu의 정상적인 작업을 방해하는 신호
  - 예외와 하드웨어 인터럽트로 나뉨
* 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램

## CPU 성능 향상 기법
* 클럭속도(Hz)가 높은 CPU는 빠르게 작동
* 코어란 CPU 내에서 명령어를 실행하는 부품(으로 여러 개 있을 수 있음)
* 멀티코어 프로세서 : 여러 개의 코어를 포함하는 CPU
* 스레드에는 하드웨어적 스레드와 소프트웨어적 스레드가 있음
  - 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위(CPU에서 사용됨)
  - 소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위(프로그램에서 사용됨)
* 멀티스레드 프로세서 : 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 말함

## 명령어 병렬 처리 기법
* 명령어 파이프라이닝 : 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
* 슈퍼스칼라 : 여러 개의 명령어 파이프라인을 두는 기법
* 비순차적 명령어 처리 기법(OoOE:Out-of-Order Execution) : 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법

## CISC와 RISC
### 명령어 집합
* CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합 또는 명령어 집합 구조(ISA, Instruction Set Architecture)
  - CPU마다 ISA가 다를 수 있음 (ex. 인텔의 노트북 속 CPU는 x86 ISA를 이해, 애플의 아이폰 속 CPU는 ARM ISA를 이해)
### CISC
* Complex Instruction Set Computer
* 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
* 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어려움
* 대다수의 복잡한 명령어는 그 사용 빈도가 낮음
* CISC 기반 CPU는 성장에 한계가 있음
### RISC
* Reduced Instruction Set Computer
* CISC에 비해 명령어의 종류가 적고, 짧고 규격화되어있음(되도록 1클럭 내외 실행되는 명령어 지향)
* └→ 고정 길이 명령어를 활용

# 메모리와 캐시메모리
## RAM의 특징과 종류
### RAM의 특징
* RAM은 휘발성 저장장치(전원을 끄면 저장된 내용이 사라짐)이고, 보조기억장치는 비휘발성 저장 장치

### DRAM(Dynamic RAM)
* 저장된 데이터가 동적으로 변하는(사라지는) RAM
* 시간이 지나면 저장된 데이터가 점차 사라지는 RAM => 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화(다시 저장)해야 함
* 소비 전력이 비교적 낮고, 저렴하고, 집적도가 높아 대용량으로 설계하기가 용이해서 위와 같은 단점이 있음에도 불구하고 일반적으로 메모리로써 사용함

### SRAM(Static RAM)
* 시간이 지나도 저장된 데이터가 사라지지 않음(시간이 지나지 않아도 사라지지 않지만, 전원 공급이 중단되면 저장된 내용이 사라지는 비휘발성 장치)
* DRAM보다 속도도 더 빠름
* DRAM보다 집적도가 낮고, 소비 전력도 크며, 가격도 비쌈 → 대용량으로 만들어질 필요는 없지만 속도가 빨라야 하는 저장 장치, 캐시 메모리에 사용됨

### SDRAM(synchronous Dynamic RAM)
* 클럭 신호와 동기화된, 발전된 형태의 DRAM(SRAM+DRAM이 아님!!)
* 클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 RAM

### DDR SDRAM(Double Data Rate SDRAM)
* 최근 가장 흔히 사용되는 RAM
* 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 대역폭 : 데이터를 주고받는 길의 너비
